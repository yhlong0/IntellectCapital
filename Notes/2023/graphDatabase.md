# Graph Database

1. Relationships are first-class citizens of the graph data model. 
2. Relational db, where join intensive query performance deteriorates as the dataset gets bigger, with a graph database performance tends to remain relatively constant, even as the dataset grows. This is because queries are localized to a portion of the graph, you start with one or multiple nodes and traversed to satisfy that query, the "hops" define your execution time rather than the size of the overall graph.
3. "What products did a customer buy" is relatively cheap compared to "Which customers bought this product?", "Which customers buying this product also bought that product" quickly become prohibitively expensive as the degree of recursion increases. 
4. To figure out which system down(app, vm, server, db, load balancer) causing user not able to use the system. `MATCH (user:User)-[*1..5]-(asset:Asset) WHERE user.name = 'User 3' AND asset.status = 'down'` This will cover a lot of relationships, user->app, user->app->db, user->app->vm->server and etc.
5. MERGE, ensuring that if some of which already exist, avoid duplication. 
6. Labels are first class citizens of the property graph model, we can index nodes with a User label and property values to support efficient node lookup(`CREATE INDEX ON :NodeLabel(name)`), or add constrain all nodes with a customer label have a unique email property value(`CREAET CONSTRAINT ON (c:Country) ASSERT c.name IS UNIQUE`). 
7. The `WITH` clause allows us to chain together several matches, with the results of the previous query part being **piped** into the next
8. Our everyday use of language might led us to focus on the verb "emailed" rather than the email itself. Instead created a emailed relationship, we need a email node.
9. In a graph, to add new facts or compositions, we tend to add new nodes and relationships rather than change the model in place. Adding to the graph using new kinds of relationships will not affect any existing queries. 
10. Here, we have entities (Person, Residence) represented not as a single node, but as a network or linked nodes. Address <- Residence <- Person -> Name, This is an extreme example of fanout, and is almost certainly overkill for any real-life solution, but some amount of fanout can be very useful. For example, splitting last names onto separate nodes helps answer the question, “Who has the last name Scott?”. Similarly, having cities as separate nodes assists with the question, “Who lives in the same city as Patrick Scott?”. The main risk about fanout is that it can lead to very dense nodes, or supernodes. These are nodes that have hundreds of thousands of incoming or outgoing relationships Supernodes need to be handled carefully.
11. When you define a property for a relationship, it is because your use cases ask a specific question about how two nodes are related, not just that they are related. We have a date property on the MARRIED relationship to further describe the relationship between Michael and Sarah. Additionally, we have a roles property on the WORKS_AT relationship to describe the roles that Michael has or had when he worked at Graph Inc. These properties are specific to the relationship between two nodes.
12. 
