# Graph Database

1. Relationships are first-class citizens of the graph data model. 
2. Relational db, where join intensive query performance deteriorates as the dataset gets bigger, with a graph database performance tends to remain relatively constant, even as the dataset grows. This is because queries are localized to a portion of the graph, you start with one or multiple nodes and traversed to satisfy that query, the "hops" define your execution time rather than the size of the overall graph.
3. "What products did a customer buy" is relatively cheap compared to "Which customers bought this product?", "Which customers buying this product also bought that product" quickly become prohibitively expensive as the degree of recursion increases. 
4. To figure out which system down(app, vm, server, db, load balancer) causing user not able to use the system. `MATCH (user:User)-[*1..5]-(asset:Asset) WHERE user.name = 'User 3' AND asset.status = 'down'` This will cover a lot of relationships, user->app, user->app->db, user->app->vm->server and etc.
5. MERGE, ensuring that if some of which already exist, avoid duplication. 
6. Labels are first class citizens of the property graph model, we can index nodes with a User label and property values to support efficient node lookup(`CREATE INDEX ON :NodeLabel(name)`), or add constrain all nodes with a customer label have a unique email property value(`CREAET CONSTRAINT ON (c:Country) ASSERT c.name IS UNIQUE`). 
7. The `WITH` clause allows us to chain together several matches, with the results of the previous query part being **piped** into the next
8. Our everyday use of language might led us to focus on the verb "emailed" rather than the email itself. Instead created a emailed relationship, we need a email node.
9. In a graph, to add new facts or compositions, we tend to add new nodes and relationships rather than change the model in place. Adding to the graph using new kinds of relationships will not affect any existing queries. 
10. Here, we have entities (Person, Residence) represented not as a single node, but as a network or linked nodes. Address <- Residence <- Person -> Name, This is an extreme example of fanout, and is almost certainly overkill for any real-life solution, but some amount of fanout can be very useful. For example, splitting last names onto separate nodes helps answer the question, “Who has the last name Scott?”. Similarly, having cities as separate nodes assists with the question, “Who lives in the same city as Patrick Scott?”. The main risk about fanout is that it can lead to very dense nodes, or supernodes. These are nodes that have hundreds of thousands of incoming or outgoing relationships Supernodes need to be handled carefully.
11. When you define a property for a relationship, it is because your use cases ask a specific question about how two nodes are related, not just that they are related. We have a date property on the MARRIED relationship to further describe the relationship between Michael and Sarah. Additionally, we have a roles property on the WORKS_AT relationship to describe the roles that Michael has or had when he worked at Graph Inc. These properties are specific to the relationship between two nodes.
12. If we find later that we need to connect something we've modeled as a relationship to more than two other entities, we'll have to refactor the entity inside the relationship out into a separate node.
13. Neo4j Redundancy, a cluster requires a majority of members to be available to work properly, Redundancy of 2 need 5 instances, 4 is no better than 3, if 2 instances become unavailable, the remaining coordinators will no longer be able to achieve majority.
14. Topology use cases:
    - which parts of the network(vm, routers, switches, fiber) do important customers depends on?
    - which app, services, customers in the network will be affected if a particular network element(routers, switches) fails?
    - Is there redundancy throughout the network for the most important customers?
15. Do not overuse labels. You should use labels wisely in your data model. They should be used if it will help with most of your use cases. A best practice is to limit the number of labels for a node to 4. Label vs properties => `MATCH (n:US) RETURN n` vs `MATCH (n:Person) WHERE n.country = 'US' RETURN n`, in Cypher, you cannot parameterize labels so keeping the country as a property makes the Cypher code more flexible.
16. Semantically orthogonal labels: labels should have nothing to do with one another. e.g. Person, Organization, Event vs Animal, Mammal, Dog. **You want to avoid labeling your nodes to represent hierarchies**, Create more nodes to represent hierarchies. 
17. 
